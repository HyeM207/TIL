# ì–‘ë°©í–¥ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (Doubly Linked Lists)
> ì–‘ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ë€, ì´ì „ì—ëŠ” next ë…¸ë“œë¡œ ë’¤ ìª½ìœ¼ë¡œë§Œ ì§„í–‰ ê°€ëŠ¥í–ˆëŠ”ë°, ì–‘ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” ì•ìœ¼ë¡œë„ ë’¤ë¡œë„ ì§„í–‰ ê°€ëŠ¥í•˜ë‹¤.


## âœ… __ë‹¬ë¼ì§„ ì __ 
1. Node êµ¬ì¡°ê°€ `.next`ì™¸ì—ë„ `.prev`ê°€ ìƒê¸´ë‹¤. 
```python
class Node:
    def __init__(self, item):
        self.data = item
        self.prev = None
        self.next = None
```
2. ë¦¬ìŠ¤íŠ¸ì´ __ì²˜ìŒê³¼ ë__ ì— dummy nodeê°€ í• ë‹¹ëœë‹¤.
     - ê·¸ë¦¬ê³  head.nextëŠ” tailë¡œ, tail.prevëŠ” headë¡œ í•˜ì—¬, ì‹œì‘ê³¼ ëì´ ì—°ê²°ë˜ëŠ” ìˆœíšë˜ëŠ” í˜•íƒœì´ë‹¤
     - __ì£¼ì˜í•´ì•¼ ë  ê²ƒì´ headê°€ ì²«ë…¸ë“œ, tailì´ ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” ê²ƒì´ ì•„ë‹ˆë‹¤. ë‹¨ìˆœ dummy nodeë¡œ ê°’ì€ í•­ìƒ None ì´ë‹¤.__   
```python
class DoublyLinkedList:

    def __init__(self):
        self.nodeCount = 0
        self.head = Node(None) # ì£¼ëª©
        self.tail = Node(None) # ì£¼ëª©
        self.head.prev = None
        self.head.next = self.tail # ì£¼ëª©
        self.tail.prev = self.head # ì£¼ëª©
        self.tail.next = None
```

3. ë¦¬ìŠ¤íŠ¸ ìˆœíšŒ
    - ì´ì œ tailë„ ë”ë¯¸ ë…¸ë“œë¼ .next.nextë¡œ ì¡°ê±´ì„ ê±¸ì–´ whileë¬¸ì„ ëˆë‹¤.
        - ë§Œì•½ ë¹ˆ ë¦¬ìŠ¤íŠ¸ì˜ ê²½ìš° 'head -> tail -> None' êµ¬ì¡°ë‹ˆê¹Œ, curr.next.nextê°€ Noneì´ ë˜ì–´  whileë¬¸ì„ ëŒì§€ ì•ŠëŠ”ë‹¤. 
```python
    def traverse(self):
        result = []
        curr = self.head
        while curr.next.next: # ì£¼ëª© 
            curr = curr.next
            result.append(curr.data)
        return result
```

4. ë¦¬ìŠ¤íŠ¸ ì—­ìˆœíšŒ 
    - ì´ì œ Nodeì— ì–‘ë°©í–¥ ì •ë³´ë¥¼ ì €ì¥í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ ì—­ìˆœíšŒë„ ê°€ëŠ¥í•˜ë‹¤.
    - ìˆœíšŒë‘ ë‹¬ë¦¬ ì‹œì‘ì„ tailë¡œ í•˜ì—¬ while curr.prev.prevë¡œ ì¡°ê±´ì„ ê±´ë‹¤.
```python
    def reverse(self):
        result = []
        curr = self.tail # ì£¼ëª© 
        while curr.prev.prev: # ì£¼ëª© 
            curr = curr.prev
            result.append(curr.data)
        return result
```
5. ì›ì†Œ ì‚½ì… (ë’¤ìª½ìœ¼ë¡œ)
    - tailê³¼ head ê³ ë ¤í•  í•„ìš”ê°€ ì—†ì–´ ì½”ë“œê°€ ê°„ë‹¨í•´ì§
    - ê³¼ì •
        - 1. next ì§€ì •
        - 2. newNodeì˜ prev, nextì§€ì •
        - 3. prev.next, next.prev ì§€ì •
```python
    def insertAfter(self, prev, newNode):
        next = prev.next
        newNode.prev = prev
        newNode.next = next
        prev.next = newNode
        next.prev = newNode
        self.nodeCount += 1
        return True
```

6. íŠ¹ì • ì›ì†Œ ì–»ì–´ë‚´ê¸° 
    - getAt()í•¨ìˆ˜ëŠ” ì´ì „ ì½”ë“œë¡œë„ ì‘ë™í•˜ì§€ë§Œ, ì½”ë“œë¥¼ ê°œì„ í•˜ë©´ ë’¤ìª½ì— ìˆëŠ” ë…¸ë“œ ì ‘ê·¼ ì‹œê°„ì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
    - ë§Œì•½ ë’¤ìª½ì˜ ë…¸ë“œë¼ë©´ tailì—ì„œë¶€í„° ì ‘ê·¼í•¨
    - ì‹œê°„ ë³µì¡ë„ëŠ” ê·¸ëŒ€ë¡œ o(n)
```python
    def getAt(self, pos):
        if pos < 0 or pos > self.nodeCount:
            return None

        if pos > self.nodeCount // 2: # ì£¼ëª© : ë’¤ìª½ë¶€í„° ì ‘ê·¼
            i = 0
            curr = self.tail # tail
            while i < self.nodeCount - pos + 1: # ì£¼ëª©(ê³„ì‚°) : ë’·í•­ì€ ë’¤ìª½ ì›ì†Œ ê°œìˆ˜ì„
                curr = curr.prev
                i += 1
        else: # ì•ìª½ë¶€í„° ì ‘ê·¼
            i = 0
            curr = self.head # head
            while i < pos:
                curr = curr.next
                i += 1

        return curr
```

7. ì›ì†Œ ì‚½ì… (ì•ìª½ìœ¼ë¡œ)
    - ì§ì ‘ êµ¬í˜„í•¨
    - insertAfter()ì™€ ë¹„ìŠ·í•œ ë¡œì§
```python
    def insertBefore(self, next, newNode):
        prev = next.prev
        prev.next = newNode
        next.prev = newNode
        newNode.next = next
        newNode.prev = prev
        self.nodeCount += 1
        return True
```

8. ì›ì†Œ ì‚­ì œ (ë’¤ìª½ìœ¼ë¡œ) 
    - ì§ì ‘ êµ¬í˜„í•¨
```python
    def popAfter(self, prev):
        curr = prev.next
        result = curr.data
        
        prev.next = curr.next
        curr.next.prev = prev
         
        del curr
        self.nodeCount -= 1
        return result
```

9. ì›ì†Œ ì‚­ì œ (ì•ìª½ìœ¼ë¡œ)
    - ì§ì ‘ êµ¬í˜„í•¨
```python
    def popBefore(self, next):
        curr = next.prev
        result = curr.data
        
        curr.prev.next = next
        next.prev = curr.prev

        del curr
        self.nodeCount -= 1 
        return result
```

10. ì›ì†Œ ì‚­ì œ
    - ì§ì ‘ êµ¬í˜„í•¨
    - prevì™€ popAfter ëŒ€ì‹  nextì™€ popBeforeë¡œ ëŒ€ì²´ ê°€ëŠ¥í•¨
```python
    def popAt(self, pos):
        if pos < 1 or pos > self.nodeCount :
            raise IndexError

        prev = self.getAt(pos - 1)
        return self.popAfter(prev)
```

11. ë‘ ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì—°ê²°
    - ì§ì ‘ êµ¬í˜„í•¨ (í—·ê°ˆë¦° ë¬¸ì œğŸ’¥)
    - l1ì—ì„œ l2ì˜ ì²«ë²ˆì§¸ ë…¸ë“œ ì—°ê²°ë§Œ í•´ì£¼ë©´ l2ì˜ ë’¤ì— ìš”ì†Œë“¤ì´ ë”°ë¼ì˜¤ê¸°ì—, ì ‘í•©ë¶€ë§Œ ì‹ ê²½ì¨ì„œ ì½”ë“œ ì§œë©´ ëœë‹¤.
    - ë§ˆì§€ë§‰ì—” self.tailë§Œ ë°”ê¿”ì£¼ë©´ ëœë‹¤.
    - ì•„ë˜ ì½”ë“œëŠ” l1ê³¼ l2ê°€ ê°ê° ë¹ˆë¦¬ìŠ¤íŠ¸ í˜¹ì€ ë‹¤ ë¹ˆë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš°ë„ ë§Œì¡±í•˜ëŠ” ì½”ë“œì´ë‹¤.
```python
    def concat(self, L):
        self.tail.prev.next = L.head.next
        L.head.next.prev = self.tail.prev
        self.tail = L.tail
        self.nodeCount += L.nodeCount
```


<br>

## âœ… __ì½”ë“œ ì „ë¬¸__ 

```python
class Node:

    def __init__(self, item):
        self.data = item
        self.prev = None
        self.next = None


class DoublyLinkedList:

    def __init__(self):
        self.nodeCount = 0
        self.head = Node(None)
        self.tail = Node(None)
        self.head.prev = None
        self.head.next = self.tail
        self.tail.prev = self.head
        self.tail.next = None


    def __repr__(self):
        if self.nodeCount == 0:
            return 'LinkedList: empty'

        s = ''
        curr = self.head
        while curr.next.next:
            curr = curr.next
            s += repr(curr.data)
            if curr.next.next is not None:
                s += ' -> '
        return s


    def getLength(self):
        return self.nodeCount


    def traverse(self):
        result = []
        curr = self.head
        while curr.next.next:
            curr = curr.next
            result.append(curr.data)
        return result


    def reverse(self):
        result = []
        curr = self.tail # ì£¼ëª© 
        while curr.prev.prev: # ì£¼ëª© 
            curr = curr.prev
            result.append(curr.data)
        return result


    def getAt(self, pos):
        if pos < 0 or pos > self.nodeCount:
            return None

        if pos > self.nodeCount // 2:
            i = 0
            curr = self.tail
            while i < self.nodeCount - pos + 1:
                curr = curr.prev
                i += 1
        else:
            i = 0
            curr = self.head
            while i < pos:
                curr = curr.next
                i += 1

        return curr


    def insertAfter(self, prev, newNode):
        next = prev.next
        newNode.prev = prev
        newNode.next = next
        prev.next = newNode
        next.prev = newNode
        self.nodeCount += 1
        return True


    def insertBefore(self, next, newNode):
        prev = next.prev
        prev.next = newNode
        next.prev = newNode
        newNode.next = next
        newNode.prev = prev
        self.nodeCount += 1
        return True


    def insertAt(self, pos, newNode):
        if pos < 1 or pos > self.nodeCount + 1:
            return False

        prev = self.getAt(pos - 1)
        return self.insertAfter(prev, newNode)


    def popAfter(self, prev):
        curr = prev.next
        result = curr.data
        
        prev.next = curr.next
        curr.next.prev = prev
         
        del curr
        self.nodeCount -= 1
        return result


    def popBefore(self, next):
        curr = next.prev
        result = curr.data
        
        curr.prev.next = next
        next.prev = curr.prev

        del curr
        self.nodeCount -= 1 
        return result


    def popAt(self, pos):
        if pos < 1 or pos > self.nodeCount :
            raise IndexError

        prev = self.getAt(pos - 1)
        return self.popAfter(prev)

    def concat(self, L):
        self.tail.prev.next = L.head.next
        L.head.next.prev = self.tail.prev
        self.tail = L.tail
        self.nodeCount += L.nodeCount
```