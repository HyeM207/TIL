# ì—°ê²°ë¦¬ìŠ¤íŠ¸

## 1ï¸âƒ£ ì—°ê²°ë¦¬ìŠ¤íŠ¸ êµ¬ì¡°
> ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” 'ë…¸ë“œ' ë“¤ì„ ì¤„ì¤„ì´ ì—®ì–´ì„œ ê´€ë¦¬í•˜ëŠ” ë°©ì‹ì´ë‹¤.   

í•˜ë‚˜ì˜ ë…¸ë“œëŠ” í¬ê²Œ _ë°ì´í„° ê°’_ ì„ ê°€ì§„ `Data`ì™€ _ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ”_ `Link (next)`ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤.  
ë…¸ë“œì˜ DataëŠ” ë‹¤ë¥¸ êµ¬ì¡°ë¡œ ì´ë¤„ì§ˆ ìˆ˜ ìˆìœ¼ë©°, ë¬¸ìì—´, ë ˆì½”ë“œ í˜¹ì€ ë˜ ë‹¤ë¥¸ ì—°ê²°ë¦¬ìŠ¤íŠ¸ê°€ ë  ìˆ˜ë„ ìˆë‹¤. 

ìµœëŒ€ ì¥ì ì€ ì‚½ì…ê³¼ ì‚­ì œê°€ ìœ ì—°í•¨


__[êµ¬ì„±ìš”ì†Œ]__
- `Node` : _ë°ì´í„° ê°’_ ì„ ê°€ì§„ `Data`ì™€ _ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ”_ `Link (next)`ë¡œ êµ¬ì„±ë¨
- `Head` : ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ì²« node ê°€ë¦¬í‚´
- `Tail` :  ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ë§ˆì§€ë§‰ node ê°€ë¦¬í‚´
- `of nodes` : ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ node ê°œìˆ˜

<br>

__[ë°°ì—´ê³¼ ë¹„êµ]__
| | ë°°ì—´  | ì—°ê²°ë¦¬ìŠ¤íŠ¸ |
|----|---|---| 
| ì €ì¥ê³µê°„ | ì—°ì†í•œ ìœ„ì¹˜ | ì„ì˜ì˜ ìœ„ì¹˜ | 
| íŠ¹ì • ì›ì†Œ ì§€ì¹­ | ë§¤ìš° ê°„í¸ | ì„ í˜•íƒìƒ‰ê³¼ ìœ ì‚¬ | 
| ì‹œê°„ ë³µì¡ë„ | O(1)  | O(n) | 

<br><br>

## 2ï¸âƒ£ ê¸°ë³¸ ì—°ê²°ë¦¬ìŠ¤íŠ¸ êµ¬í˜„ (Python)
### âœ… ì½”ë“œ ì„¤ëª… 
__class__ 
- `Node` : ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬ì„±í•˜ëŠ” ë…¸ë“œ ê°ì²´ë¡œ ê°’ì„ ë‹´ëŠ” `data`ì™€ ë‹¤ìŒ ì›ì†Œë¥¼ ê°€ë¦¬í‚¤ëŠ” `next` ë³€ìˆ˜ë¡œ êµ¬ì„±ë¨
- `LinkedList` : Nodeë¥¼ ì›ì†Œë¡œ í•˜ëŠ” ì—°ê²°ë¦¬ìŠ¤íŠ¸ êµ¬í˜„ì²´ë¡œ, ë…¸ë“œ ê°œìˆ˜ì¸ `nodeCount`, ì²« ì›ì†Œ ê°€ë¦¬í‚¤ëŠ” `head`, ë ì›ì†Œë¥¼ ê°€ì¹˜í‚¤ëŠ” `tail`ë¡œ êµ¬ì„±ë¨
    - ì´ë•Œ ì²« ë²ˆì§¸ ì›ì†Œ ì¸ë±ìŠ¤ëŠ” 0ì´ ì•„ë‹Œ __1__ ë¡œ í•œë‹¤.

__ì—°ê²°ë¦¬ìŠ¤íŠ¸ í•¨ìˆ˜__
1. `getAt()` 
    - ê¸°ëŠ¥ : posë²ˆì§¸ ë…¸ë“œ ë°˜í™˜ 
    - êµ¬í˜„ : 
        - headë¶€í„° nodeCountë²ˆì§¸ê¹Œì§€ ëŒë©° ië²ˆì§¸ ì°¾ê¸°
        - ì´ë•Œ ì´ë™ì€ .nextë¥¼ ì´ìš©í•˜ì—¬ ë‹¤ìŒ ë…¸ë“œë¡œ ì´ë™
2. `traverse()` 
    - ê¸°ëŠ¥ : ë¦¬ìŠ¤íŠ¸ ìˆœíšŒí•˜ë©° ëª¨ë“  ë…¸ë“œ ê°’ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    - êµ¬í˜„ : 
        - headë¶€í„° ë§ˆì§€ë§‰ ë…¸ë“œê¹Œì§€ whileë¬¸ ëŒë ¤ .next ì´ë™
3. `getLength()`
    - ê¸°ëŠ¥ : ì—°ê²°ë¦¬ìŠ¤íŠ¸ ê¸¸ì´(nodeCount) ë¦¬í„´
4. `insertAt()` 
    - ê¸°ëŠ¥ : íŠ¹ì • ìœ„ì¹˜(posë²ˆì§¸)ì— ì›ì†Œ(ë…¸ë“œ) ì‚½ì…
    - êµ¬í˜„ : 
        - ì‚½ì… ìœ„ì¹˜(pos)ê°€ ì ì ˆí•œì§€ íŒë‹¨
        - ë§Œì•½ ì‚½ì… ìœ„ì¹˜ê°€ ë§¨ ì•ì´ë©´, prev ì—†ê³  Head ì¡°ì • í•„ìš”
        - 1. ìƒˆ ë…¸ë“œì˜ next ì¡°ì •
        - 2. ê¸°ì¡´ì˜ prev ë…¸ë“œì˜ nextë¥¼ ìƒˆ ë…¸ë“œë¡œ ì§€ì •
        - 3. nodeCount += 1
        - ë§Œì•½ ì‚½ì… ìœ„ì¹˜ê°€ ë§¨ ëì´ë©´, Tail ì¡°ì • í•„ìš”
5. `popAt()`
    - ê¸°ëŠ¥ : pos ìœ„ì¹˜ ì›ì†Œ ì‚­ì œ í›„ ê°’ ë¦¬í„´
    - êµ¬í˜„ :
        - ì‚­ì œ ìœ„ì¹˜(pos)ê°€ ì ì ˆí•œì§€ íŒë‹¨
        - 1. prev.next <- curr.next
        - 2. ì‚­ì œí•  ë…¸ë“œ ê°’ ê°€ì ¸ì˜¤ê³  ì‚­ì œ
        - 3. nodeCount -= 1
        - ë§Œì•½ ì‚­ì œ ë…¸ë“œê°€ ë§¨ ì•ì´ë©´, prev ì—†ê³  Head ì¡°ì • í•„ìš”
        - ë§Œì•½ ì‚­ì œ ë…¸ë“œê°€ ë§¨ ëì´ë©´ Tail ì¡°ì • í•„ìš”
6. `concat()`
    - ê¸°ëŠ¥ : ë‘ ë¦¬ìŠ¤íŠ¸ í•©ì¹˜ê¸° (ì—°ê²°)
    - êµ¬í˜„ : 
        - self.tail.next = L2.head
        - self.tail = l2.tail
        - nodeCount + = l2.nodeCount

### âœ… ì½”ë“œ  

``` python
class Node:
    def __init__(self, item):
        self.data = item
        self.next = None

class LinkedList:
    def __init__(self):
        self.nodeCount = 0
        self.head = None
        self.tail = None

    def getAt(self, pos):
        if pos < 1 or pos > self.nodeCount:
            return None
        i = 1
        curr = self.head
        while i < pos:
            curr = curr.next
            i += 1
        return curr

    def getLength(self):
        return self.nodeCount

    def traverse(self):
        nodes = []
        curr = self.head
        while curr is not None : 
            nodes.append(curr.data)
            curr = curr.next
        return nodes

    def insertAt(self, pos, newNode):
        if pos < 1 or pos > self.nodeCount + 1:
            return False

        if pos == 1:
            newNode.next = self.head
            self.head = newNode

        else:
            # ë§ˆì§€ë§‰ì— ì‚½ì…ì‹œì—ëŠ” prevë¥¼ ì²˜ìŒë¶€í„° ì°¾ì•„ê°ˆ í•„ìš”ì—†ì´ tailì„
            if pos == self.nodeCount + 1:
                prev = self.tail
            else:
                prev = self.getAt(pos - 1)
            newNode.next = prev.next
            prev.next = newNode

        if pos == self.nodeCount + 1:
            self.tail = newNode

        self.nodeCount += 1
        return True

    def concat(self, L):
        self.tail.next = L.head
        if L.tail:
            self.tail = L.tail
        self.nodeCount += L.nodeCount

    def popAt(self, pos):
        if pos < 1 or pos > self.nodeCount :
            raise IndexError
            
        if pos == 1:
            curr = self.head
            self.head = self.head.next
            if pos == self.nodeCount : # ë…¸ë“œ 1ê°œì¼ ê²½ìš°
                self.tail = self.head
        else :
            prev = self.getAt(pos - 1)
            curr = prev.next
            prev.next = curr.next
            if pos == self.nodeCount : # ë ë…¸ë“œì¼ ê²½ìš°
                self.tail = prev
            
        self.nodeCount -= 1
        result = curr.data
        del curr
        return result
```
-  popAT()í•¨ìˆ˜ì˜ ê²½ìš° ê°•ì˜ì— ì—†ê³  ê³¼ì œë¡œ ì§ì ‘ êµ¬í˜„í•´ì•¼ëë‹¤.
- ğŸ’¥ ë§‰íŒ ë¶€ë¶„ì„ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
    - return valueë¥¼ ì‚­ì œí•œ ë…¸ë“œì˜ "ê°’"ì„ ë¦¬í„´í•´ì•¼ë˜ëŠ”ë°, ë…¸ë“œ ìì²´ë¥¼ ë¦¬í„´í•´ì„œ ë§‰í˜”ì—ˆë‹¤..ğŸ˜€

### âœ…  ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì—°ì‚°ë³„ ë³µì¡ë„
#### ì›ì†Œ ì‚½ì… 
- ë§¨ ì• ì‚½ì… : O(1)
- ì¤‘ê°„ ì‚½ì… : O(n)
- ë§¨ ë ì‚½ì…  : O(1)

#### ì›ì†Œ ì‚­ì œ
- ë§¨ ì• ì‚½ì… : O(1)
- ì¤‘ê°„ ì‚½ì… : O(n)
- ë§¨ ë ì‚½ì…  : O(n)

<br><br>

## 3ï¸âƒ£ ë³€í˜•ëœ ì—°ê²°ë¦¬ìŠ¤íŠ¸ êµ¬í˜„ (Python)
> ê¸°ë³¸ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ê²½ìš° ì‚½ì…ê³¼ ì‚­ì œë¥¼ í•˜ëŠ”ë° getAt()í•¨ìˆ˜ë¥¼ ì¨ì„œ ì¸ë±ìŠ¤ë¡œ ì ‘ê·¼í•´ì•¼ëœë‹¤ëŠ” ë‹¨ì ì´ ì¡´ì¬í•œë‹¤. ì‚½ì…ê³¼ ì‚­ì œê°€ ì¥ì ì¸ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ì¥ì ì„ ê·¹ëŒ€í™”í•˜ê³ ì ì½”ë“œë¥¼ ë³€í˜•í•˜ì—¬ ì‚½ì…ê³¼ ì‚­ì œì˜ ì†ë„ë¥¼ ë†’ì¸ë‹¤.



### âœ… ë³€ê²½ëœ ì  
ë§¨ ì•ì— dummy nodeë¥¼ ì¶”ê°€í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™” ì‹œ __headê°€ Noneì´ ì•„ë‹Œ ë¹ˆ ë…¸ë“œ(dummy node)ê°€ ë””í´íŠ¸__ ì´ë‹¤. 

ë˜í•œ, ìƒˆë¡œìš´ ë§¤ì„œë“œ `insertAfter(prev, newNode)` ì™€ `popAfter(prev)`ê°€ ìƒê²¼ë‹¤.   
íŠ¹íˆ, `insertAfter` í•¨ìˆ˜ì˜ ê²½ìš° ë§¤ê°œë³€ìˆ˜ë¡œ ì‚½ì… ìœ„ì¹˜ì¸ posê°€ ì•„ë‹Œ `newNode`ì˜ ë…¸ë“œ ê°ì²´ë¥¼ ë„˜ê²¨ì¤€ê³  ì´ì „ë…¸ë“œë¥¼ `prev`ë¡œ ë…¸ë“œ ê°ì²´ë¥¼ ë„˜ê²¨ì¤€ë‹¤. 


### âœ… ì½”ë“œ
```python
class Node:
	def __init__(self, item):
		self.data = item
		self.next = None

class LinkedList:
	def __init__(self):
		self.nodeCount = 0
		self.head = Node(None) # ìƒˆ ë…¸ë“œ í• ë‹¹
		self.tail = None
		self.head.next = self.tail # ì¶”ê°€ 


	def __repr__(self):
		if self.nodeCount == 0:
			return 'LinkedList: empty'

		s = ''
		curr = self.head
		while curr.next:
			curr = curr.next
			s += repr(curr.data)
			if curr.next is not None:
				s += ' -> '
		return s


	def getLength(self):
		return self.nodeCount


	def traverse(self):
		result = []
		curr = self.head
        # ë³€ê²½ì‚¬í•­ : curr.nextë¡œ ë¨¼ì € ì´ë™í•˜ê³  ê°’ì„ ë¹¼ì˜¨ë‹¤.
		while curr.next:
			curr = curr.next
			result.append(curr.data)
		return result


	def getAt(self, pos):
        # ë³€ê²½ì‚¬í•­ : 1ì´ ì•„ë‹Œ 0ë¶€í„° head ì‹œì‘
		if pos < 0 or pos > self.nodeCount:
			return None

		i = 0 # ë³€ê²½ë¨
		curr = self.head
		while i < pos:
			curr = curr.next
			i += 1

		return curr


	def insertAfter(self, prev, newNode):
		newNode.next = prev.next
		if prev.next is None: # prevê°€ tail ë…¸ë“œì¸ ê²½ìš°
			self.tail = newNode
		prev.next = newNode
		self.nodeCount += 1
		return True


	def insertAt(self, pos, newNode):
		if pos < 1 or pos > self.nodeCount + 1:
			return False

        # tailë’¤ì— ì‚½ì…í•˜ëŠ” ê²½ìš° (pos ==1 ë¡œ ë˜ë²„ë¦¬ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸ì™€ ê°™ê¸° ë•Œë¬¸ì´ë‹¤)
		if pos != 1 and pos == self.nodeCount + 1: 
			prev = self.tail
		else: # ì¤‘ê°„&ë§¨ ì•ì— ì‚½ì… 
			prev = self.getAt(pos - 1)
		return self.insertAfter(prev, newNode)


	def concat(self, L):
		self.tail.next = L.head.next
		if L.tail:
			self.tail = L.tail
		self.nodeCount += L.nodeCount


    def popAfter(self, prev):
        curr = prev.next
        result = curr.data
        
        # ë§ˆì§€ë§‰ ë…¸ë“œ ì‚­ì œ ì‹œ tail ì¡°ì • í•„ìš”
        if curr.next is None: 
            self.tail = prev
        
        prev.next = curr.next
        del curr
        self.nodeCount -= 1
        return result


    def popAt(self, pos):
        if pos < 1 or pos > self.nodeCount:
            raise IndexError

        # ì´ì „ ë…¸ë“œë¥¼ ì´ìš©í•˜ê¸°ì— tail ì‚­ì œ ì‹œì—ë„ getAt()í•¨ìˆ˜ë¥¼ ì´ìš©í•´ì•¼ ëœë‹¤
        prev = self.getAt(pos - 1)
        return self.popAfter(prev)
```

- popAfter()ì™€ popAT()í•¨ìˆ˜ì˜ ê²½ìš° ê°•ì˜ì— ì—†ê³  ê³¼ì œë¡œ ì§ì ‘ êµ¬í˜„í•´ì•¼ëë‹¤.
- ğŸ’¥ ë§‰íŒ ë¶€ë¶„ì„ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
    - (1) `popAt()`ì—ì„œ ë§ˆì§€ë§‰ ë…¸ë“œ ì‚­ì œ ì‹œ `prev = self.tail`ë¡œ í•´ë²„ë¦¼
        - prevëŠ” ë§ê·¸ëŒ€ë¡œ ì´ì „ ë…¸ë“œì¸ë° ìê¾¸ tail ë…¸ë“œë¥¼ ë„£ì–´ì„œ ì•ˆ ëì—ˆë‹¤. ìƒê°í•˜ê³  ì½”ë”©í•˜ì..ğŸ˜…
    - (2) `popAfter()`ì—ì„œ ë…¸ë“œê°€ í•˜ë‚˜ì¼ ê²½ìš°ë¥¼ ê³ ë ¤í•˜ì—¬ `if prev.data is None : self.head = self.tail` ë¼ëŠ” ì½”ë“œë¥¼ ì§°ëŠ”ë° ì´ëŠ” í•„ìš”ì—†ëŠ” ì½”ë“œì˜€ë‹¤.
        - ê·¸ ì´ìœ ëŠ” í•´ë‹¹ ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” __ì²˜ìŒë¶€í„° headë¥¼ ë”ë¯¸ ë…¸ë“œë¡œ ì§€ì •__ í•˜ì˜€ê¸° ë•Œë¬¸ì—, headë¥¼ ì¡°ì •í•´ì¤„ í•„ìš” ì—†ì—ˆë‹¤.