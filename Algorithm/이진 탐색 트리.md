# ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (Binary Search Trees)
## ğŸ“Œ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ë€?
1ï¸âƒ£ ëª¨ë“  ë…¸ë“œì— ëŒ€í•´ì„œ ì•„ë˜ ì„±ì§ˆì„ ë§Œì¡±í•˜ëŠ” ì´ì§„íŠ¸ë¦¬  

- __ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬__ ì— ìˆëŠ” ë°ì´í„°ëŠ” ëª¨ë‘ í˜„ì¬ ë…¸ë“œ ê°’ë³´ë‹¤ __ì‘ìŒ__
- __ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬__ ì— ìˆëŠ” ë°ì´í„°ëŠ” ëª¨ë‘ í˜„ì¬ ë…¸ë“œ ê°’ë³´ë‹¤ __í¼__
- (ë‹¨ ì¤‘ë³µë˜ëŠ” ë°ì´í„° ì›ì†ŒëŠ” ì—†ëŠ” ê²ƒìœ¼ë¡œ ê°€ì •í•¨)


2ï¸âƒ£ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ë¥¼ ì´ìš©í•œ ë°ì´í„° ê²€ìƒ‰ Good!  
- ì‹œê°„ ë³µì¡ë„  : `O(log N)`
- ì •ë ¬ëœ ë°°ì—´ì„ ì´ìš©í•œ ì´ì§„ íƒìƒ‰ê³¼ ë¹„ìŠ·í•¨. ë¹„êµë¥¼ í•´ë³¸ë‹¤ë©´?  
    ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ì¥ë‹¨ì ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.  
    - ì¥ì  : ë°ì´í„° ì›ì†Œ ì¶”ê°€, ì‚­ì œ ìš©ì´
    - ë‹¨ì  : ê³µê°„ ì†Œìš” í¼ 


3ï¸âƒ£ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ê°€ íš¨ìœ¨ì ì´ì§€ ëª»í•œ ê²½ìš°
- í•œ ìª½ìœ¼ë¡œ ì¹˜ìš°ì³ì§„ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì‹œ ì„ í˜•íƒìƒ‰ê³¼ ê°™ì•„ë²„ë¦¬ë‹ˆ íš¨ìœ¨ì ì´ì§€ ëª»í•˜ë‹¤.  
 
4ï¸âƒ£ ë” ë‚˜ì€ ì„±ëŠ¥ì„ ë³´ì´ëŠ” ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬
- ë†’ì´ ê· í˜•ì„ ìœ ì§€í•˜ëŠ” íŠ¸ë¦¬ëŠ” O(logN) íƒìƒ‰ ë³µì¡ë„ ë³´ì¥í•¨ (ëŒ€ì‹  ì‚½ì…, ì‚­ì œ ì—°ì‚°ì´ ë³´ë‹¤ ë³µì¡í•¨)
- AVLíŠ¸ë¦¬, ë ˆë“œ-ë¸”ë™ íŠ¸ë¦¬

<br>

## ğŸ“Œ ì´ì§„ íƒìƒ‰íŠ¸ë¦¬ ì¶”ìƒì  ìë£Œ êµ¬ì¡°
ë°ì´í„° í‘œí˜„ì€ ê° ë…¸ë“œëŠ” `(key, value)`ì˜ ìŒ  
- í‚¤ ì´ìš©í•´ ê²€ìƒ‰ ê°€ëŠ¥ 
- ë³µì¡í•œ ë°ì´í„° ë ˆì½”ë“œë¡œ í™•ì¥ ê°€ëŠ¥


### âœ… __ì—°ì‚° ì¢…ë¥˜__  
- `insert(key, data)` : íŠ¸ë¦¬ì— í•´ë‹¹ ì›ì†Œ ì¶”ê°€
- `remove(key)` : í•´ë‹¹ ì›ì†Œ íŠ¸ë¦¬ì—ì„œ ì‚­ì œ 
- `lookup(key)` : íŠ¹ì • ì›ì†Œ ê²€ìƒ‰
- `inorder()` : í‚¤ì˜ ìˆœì„œëŒ€ë¡œ ë°ì´í„° ì›ì†Œ ë‚˜ì—´
- `min()`, `max()` : ìµœì†Œ í‚¤, ìµœëŒ€ í‚¤ë¥¼ ê°€ì§€ëŠ” ì›ì†Œ ê°ê° íƒìƒ‰

### âœ… ì‚­ì œ ê³¼ì • 
1. keyë¡œ ì‚­ì œí•  ë…¸ë“œë¥¼ ì°¾ëŠ”ë‹¤
    - ì—†ìœ¼ë©´ ì‚­ì œí•  ê²ƒë„ ì—†ìŒ
    - ìˆìœ¼ë©´ ë¶€ëª¨ë…¸ë“œë„ ì•Œê³ ìˆì–´ì•¼í•¨   
    (í•´ë‹¹ ë…¸ë“œ ì‚­ì œ í›„ì—ë„ ì´ì§„íƒìƒ‰ íŠ¸ë¦¬ ì„±ì§ˆì„ ë§Œì¡±í•˜ë„ë¡ __íŠ¸ë¦¬ êµ¬ì¡° ì •ë¦¬__ í•„ìš”í•¨)
2. ì‚­ì œ í›„ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ êµ¬ì¡° __ìœ ì§€__
    - "ë§ë‹¨ leaf" ë…¸ë“œ ì‚­ì œ ì‹œ
        - í•´ë‹¹ ë…¸ë“œ ì‚­ì œ í›„ __ë¶€ëª¨ ë…¸ë“œì˜ ì¢Œ/ìš° ë§í¬ë¥¼ ì¡°ì •__ 
    - "ìì‹ í•˜ë‚˜" ê°€ì§€ê³  ìˆëŠ” ë…¸ë“œ ì‚­ì œ ì‹œ
        - ì‚­ì œë˜ëŠ” ë…¸ë“œ ìë¦¬ì— ì™¼ìª½/ì˜¤ë¥¸ìª½ __ìì‹ì„ ëŒ€ì‹  ë°°ì¹˜__
        - __ë¶€ëª¨ ë…¸ë“œì˜ ì¢Œ/ìš° ë§í¬ë¥¼ ì¡°ì •__ 
        - ë§Œì•½ ì‚­ì œí•˜ëŠ” ë…¸ë“œê°€ rootì´ë©´ í›„ì† ì²˜ë¦¬ í•„ìš”
    - "ìì‹ ë‘˜" ê°€ì§€ê³  ìˆëŠ” ë…¸ë“œ ì‚­ì œ ì‹œ 
        - ì‚­ì œë˜ëŠ” ë…¸ë“œë³´ë‹¤ __ë°”ë¡œ ë‹¤ìŒìœ¼ë¡œ í° í‚¤ë¥¼ ê°€ì§€ëŠ” ë…¸ë“œ(successor)ë¥¼ ì°¾ê³ __, ì‚­ì œë˜ëŠ” ìë¦¬ì— __ëŒ€ì‹  ë°°ì¹˜__ í•¨
        - ë§Œì•½ successorê°€ ìì‹ì„ ê°–ê³  ìˆìœ¼ë©´ í•´ë‹¹ ìì‹ í›„ì†ì²˜ë¦¬ë„ í•„ìš”í•¨

<br>

## ğŸ“Œ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ êµ¬í˜„ ì½”ë“œ
```python
class Node:

    def __init__(self, key, data):
        self.key = key # key ì¶”ê°€ë¨
        self.data = data
        self.left = None
        self.right = None


    def min(self):
        if self.left : 
            return self.left.min()
        else :
            return self


    def max(self):
        if self.right : 
            return self.right.max()
        else :
            return self


    def lookup(self, key, parent=None) : # í•µì‹¬ 
        if key < self.key : 
            if self.left : 
                return self.left.lookup(key, self) # self.leftì˜ ë¶€ëª¨ëŠ” self
            else :
                return None, None
        elif key > self.key :
            if self.right : 
                return self.right.lookup(key, self) 
            else :
                return None, None
        else :
            return self, parent


    def insert(self, key, data):
        if key < self.key : 
            if self.left : 
                return self.left.insert(key, data) 
            else :
                self.left =  Node(key, data)
        elif key > self.key :
            if self.right : 
                return self.right.insert(key, data) 
            else :
                self.right = Node(key, data)
        else :
            raise KeyError('...')


    def inorder(self):
        traversal = []
        if self.left:
            traversal += self.left.inorder()
        traversal.append(self)
        if self.right:
            traversal += self.right.inorder()
        return traversal


    def countChildren(self):
        count = 0
        if self.left:
            count += 1
        if self.right:
            count += 1
        return count


class BinSearchTree:

    def __init__(self):
        self.root = None


    def min(self):
        if self.root:
            return self.root.min()
        else:
            return None


    def max(self):
        if self.root:
            return self.root.max()
        else:
            return None


    def lookup(self, key):
        if self.root:
            return self.root.lookup(key)
        else:
            return None, None


    def insert(self, key, data):
        if self.root:
            self.root.insert(key, data)
        else:
            self.root = Node(key, data)


    def remove(self, key):
        # <<TODO>>

    def inorder(self):
        if self.root:
            return self.root.inorder()
        else:
            return []



def solution(x):
    return 0
```
1. `__init__ `  
    - Node   
        - __key__ , data, left child, right child
    - BinaryTree
        - root= __None__

2. `inorder()`
    - `traversal` ë¦¬í„´ ë¦¬ìŠ¤íŠ¸ê°€ dataê°€ ì•„ë‹Œ `self`ì„

3. `min()`, `max()`
    - `min()`: `Node`ì—ì„œëŠ” ê³„ì† ì™¼ìª½ìœ¼ë¡œë§Œ íƒìƒ‰í•˜ë©´ ì‘ì€ ê°’ì„ (ì´ì§„íƒìƒ‰íŠ¸ë¦¬ íŠ¹ì§•)
    - `max()`:  `min()` ê³¼ ëŒ€ì¹­

4. `lookup()` (í•µì‹¬)
    - ì¬ê·€ì  êµ¬í˜„
    - "ì…ë ¥ì¸ì"ëŠ” ì°¾ìœ¼ë ¤ëŠ” ëŒ€ìƒì˜ __í‚¤__, "ë¦¬í„´"ì€ __ì°¾ì€ ë…¸ë“œì™€ ê·¸ê²ƒì˜ ë¶€ëª¨__ (ì—†ìœ¼ë©´ None)
    
5. `insert()`
    - ì¬ê·€ì  êµ¬í˜„
    - "ì…ë ¥ì¸ì"ëŠ” ì°¾ìœ¼ë ¤ëŠ” ëŒ€ìƒì˜ __í‚¤ì™€ ì‚½ì…í•  ë°ì´í„°__, "ë¦¬í„´"ì€ ì—†ìŒ


- 