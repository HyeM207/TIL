# νΈλ¦¬ (Trees)
## π“ νΈλ¦¬λ€?
- `μ •μ (node)`κ³Ό `κ°„μ„ (edge)`μ„ μ΄μ©ν•μ—¬ λ°μ΄ν„° λ°°μΉ ν•νƒλ¥Ό μ¶”μƒν™”ν• μλ£ κµ¬μ΅°
- rootλ” μ„μ½μ— leafλ” μ•„λμ½μ— μ„μΉν•¨
- `λ¶€λ¨(Parent)`μ™€ `μμ‹(Child)` λ…Έλ“ 
    - λ¶€λ¨λ” rootμ½, μμ‹ λ…Έλ“λ” leafμ½μ— λ¶€λ¨ λ…Έλ“μ™€ μ—°κ²°λ λ…Έλ“μ„
    - ν• λ…Έλ“ κΈ°μ¤€μΌλ΅ μμ‹ λ…Έλ“λ” μ—¬λ¬κ° μΌ μμμ§€λ§, _λ¶€λ¨ λ…Έλ“λ” ν•λ‚_ μλ” κ²ƒμ΄ νΈλ¦¬μ νΉμ§•
    - κ°™μ€ λ¶€λ¨ μ•„λ μλ” λ…Έλ“λ“¤μ κ΄€κ³„λ” `ν•μ κ°„(sibling)`
    - λ¶€λ¨μ λ¶€λ¨ : `μ΅°μƒ(ancestor)`
    - μμ‹μ μμ‹ : `ν›„μ†(descendant)`
        - λ£¨νΈ λ…Έλ“λ¥Ό μ μ™Έν• λ¨λ“  λ…Έλ“λ“¤μ€ λ£¨νΈμ ν›„μ†μ„
    
- `λ…Έλ“μ μμ¤€(level)`
    - rootλ” λ³΄ν†µ lv1, κ·Έ μ•„λλ” lv2 ...

- `νΈλ¦¬μ λ†’μ΄/κΉμ΄ (height)`
    - νΈλ¦¬μ λ†’μ΄ = μµλ€ μμ¤€ (level) + 1

- λ¶€λ¶„νΈλ¦¬(`μ„λΈνΈλ¦¬(Subtree)`)
- `λ…Έλ“μ μ°¨μ(Degree)`
    - μ°¨μ(degree): μμ‹(μ„λΈνΈλ¦¬) κ°μ
    - childλ…Έλ“κ°€ μ—†λ”(degreeκ°€ 0) μ΄λ©΄ `leaf node`λΌκ³  ν•¨


<br><br>

# μ΄μ§„ νΈλ¦¬ 
## π“ μ΄μ§„ νΈλ¦¬λ€?
- λ¨λ“  λ…Έλ“μ __μ°¨μκ°€ 2μ΄ν•μΈ__ νΈλ¦¬ (κ° λ…Έλ“μ μμ‹μ΄ 2κ° μ΄ν•) νΉμ€ __λΉ νΈλ¦¬ (empty tree)__
- `μ¬κ·€μ `μΌλ΅ μ •μ κ°€λ¥ν•¨
    - λ£¨νΈ λ…Έλ“ + μ™Όμ½ μ„λΈνΈλ¦¬ + μ¤λ¥Έμ½ μ„λΈνΈλ¦¬   
    (λ‹¨ μ΄λ• μ™Όμ½κ³Ό μ¤λ¥Έμ½ μ„λΈνΈλ¦¬λ„ μ΄μ§„νΈλ¦¬μ„)

### [ νΉλ³„ν• μ΄μ§„ νΈλ¦¬  ]
#### (1) ν¬ν™” μ΄μ§„ νΈλ¦¬(Full Binary Tree)
- __λ¨λ“  λ λ²¨μ—μ„ λ…Έλ“λ“¤μ΄ λ¨λ‘ μ±„μ›μ Έ μλ” μ΄μ§„ νΈλ¦¬__
- λ†’μ΄κ°€ kμ΄κ³  λ…Έλ“μ κ°μκ°€ `2^k - 1`

#### (2) μ™„μ „ μ΄μ§„ νΈλ¦¬ (Complete)
- λ†’μ΄ kμΈ μ™„μ „ μ΄μ§„ νΈλ¦¬λΌ κ°€μ •ν•λ©΄ 
    - λ λ²¨ k-2κΉμ§€λ” λ¨λ“  λ…Έλ“κ°€ 2κ°μ μμ‹μ„ κ°€μ§„ ν¬ν™”μ΄μ§„ νΈλ¦¬ ν•νƒ
    - λ λ²¨ k-1μ—μ„λ” __μ™Όμ½λ¶€ν„° λ…Έλ“κ°€ μμ°¨μ μΌλ΅ μ±„μ›μ Έ__ μλ” μ΄μ§„ νΈλ¦¬ 

<br>

## π“ μ΄μ§„ νΈλ¦¬ μ¶”μƒμ  μλ£ κµ¬μ΅°
### β… __μ—°μ‚° μΆ…λ¥__  
- `size()` :  ν„μ¬ νΈλ¦¬μ— ν¬ν•¨λμ–΄ μλ” λ…Έλ“μ μ
- `depth()`L ν„μ¬ νΈλ¦¬μ κΉμ΄/λ†’μ΄
- `μν (traversal)`
    - κΉμ΄ μ°μ„  μν (depth first traversal)
        - μ¤‘μ„ μν (in-order traversal)
        - μ „μ„ μν (pre-order traversal)
        - ν›„μ„ μν (post-order traversal)
    - λ„“μ΄ μ°μ„  μν (breadth first traversal)

<br>

### β… __μν μμ„__   
#### (1) κΉμ΄ μ°μ„  μν
- μ¬κ·€ λ°©μ‹μΌλ΅ κµ¬ν„ 
> μ¤‘μ„ μν in-order    
     : left subtree -> μκΈ° μμ‹  -> right subtree

> μ „μ„ μν pre-order   
     : μκΈ° μμ‹  -> left subtree -> right subtree

> ν›„μ„ μν post-order   
      : left subtree -> right subtree -> μκΈ°μμ‹ 

<br>

#### (2) λ„“μ΄ μ°μ„  μν
- μμ¤€levelμ΄ λ‚®μ€ λ…Έλ“ μ°μ„  λ°©λ¬Έ    
    (λ£¨νΈλ¶€ν„° λ°©λ¬Έν•μ—¬ μ™Όμ½-> μ¤λ¥Έμ½μΌλ΅ λ°©λ¬Έ)
- κ°™μ€ μμ¤€ λ…Έλ“ μ‚¬μ΄μ—μ„λ”
    - λ¶€λ¨ λ…Έλ“ λ°©λ¬Έ μμ„μ— λ”°λΌ λ°©λ¬Έν•κ³ , μ™Όμ½ μμ‹ λ…Έλ“λ¥Ό μ¤λ¥Έμ½ μμ‹ λ…Έλ“λ³΄λ‹¤ λ¨Όμ € λ°©λ¬Έν•λ‹¤.
- μ¬κ·€ λ°©μ‹μ€ μ ν•©ν•μ§€ μ•μ
- ν• λ…Έλ“ λ°©λ¬Έμ‹, μ•μΌλ΅ λ°©λ¬Έν•  λ…Έλ“λ¥Ό μμ„λ€λ΅ μ €μ¥ν•κΈ° μ„ν•΄ `Queue` μ΄μ©λ¨

<br>


## π“ μ΄μ§„ νΈλ¦¬ κµ¬ν„ μ½”λ“
```python
class ArrayQueue:

    def __init__(self):
        self.data = []

    def size(self):
        return len(self.data)

    def isEmpty(self):
        return self.size() == 0

    def enqueue(self, item):
        self.data.append(item)

    def dequeue(self):
        return self.data.pop(0)

    def peek(self):
        return self.data[0]


class Node:

    def __init__(self, item):
        self.data = item
        self.left = None
        self.right = None


    def size(self):
        l = self.left.size() if self.left else 0
        r = self.right.size() if self.right else 0
        return l + r + 1


    def depth(self):
        l = self.left.depth() if self.left else 0
        r = self.right.depth() if self.right else 0
        return max(l,r) + 1

    def inorder(self):
        traversal = []
        if self.left:
            traversal += self.left.inorder()
        traversal.append(self.data)
        if self.right:
            traversal += self.right.inorder()
        return traversal


    def preorder(self):
        traversal = []
        traversal.append(self.data)
        if self.left:
            traversal += self.left.preorder()
        if self.right:
            traversal += self.right.preorder()
        return traversal


    def postorder(self):
        traversal = []
        if self.left:
            traversal += self.left.postorder()
        if self.right:
            traversal += self.right.postorder()
        traversal.append(self.data)
        return traversal


class BinaryTree:

    def __init__(self, r):
        self.root = r

    def size(self):
        if self.root:
            return self.root.size()
        else:
            return 0


    def depth(self):
        if self.root:
            return self.root.depth()
        else:
            return 0


    def inorder(self):
        if self.root:
            return self.root.inorder()
        else:
            return []


    def preorder(self):
        if self.root:
            return self.root.preorder()
        else:
            return []


    def postorder(self):
        if self.root:
            return self.root.postorder()
        else:
            return []


    def bft(self):
        traversal = []
        visit = ArrayQueue()
        
        if self.root :
            visit.enqueue(self.root)
            
        while not visit.isEmpty() :
            node = visit.dequeue()
            traversal.append(node.data)
            if node.left :
                visit.enqueue(node.left) 
            if node.right :
                visit.enqueue(node.right)  
        return traversal

def solution(x):
    return 0
```

1. `__init__ `  
    - Node   
        - data, left child, right child
    - BinaryTree
        - root
2. `size()`
    - recursive κµ¬ν„ κ°€λ¥
    - μ „μ²΄ μ΄μ§„ νΈλ¦¬ size = left subtree size + right subtree size + 1 (μκΈ°μμ‹ )

3. `depth()`
    - recursive κµ¬ν„ κ°€λ¥
    - μ „μ²΄ μ΄μ§„ νΈλ¦¬ depth = left subtree depthμ™€ right subtree depth μ¤‘ λ” ν°κ²ƒ + 1

4. `inorder()`, `preorder()`, `postorder()`
    - μν μμ„λ”°λΌ κµ¬ν„ν•λ©΄ λ¨

5. `bft()`
    - lv λ‚®μ€κ²ƒ λ¶€ν„° μ‹μ‘ν•λ”λ°, μ΄λ• __μμ‹ κ³Ό μμ‹μ„ νμ— μ μ¬__   
    => __λ‹¤μ λ…Έλ“ λ°©λ¬Έμ‹ νμ—μ„ ν•λ‚μ”© κΊΌλƒ„__ 